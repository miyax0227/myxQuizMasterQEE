{"headers":[{"key":"pos","value":true,"style":"boolean"},{"key":"nowSet","value":0,"style":"number"}],"items":[{"key":"o","value":0,"style":"number","css":"o"},{"key":"x","value":0,"style":"number","css":"x"},{"key":"combo","value":0,"style":"number","css":"combo"},{"key":"order","value":-1,"style":"number"}],"priority":[{"key":"status","order":"desc","alter":["win",2,"lose",0,1]},{"key":"o","order":"desc"},{"key":"x","order":"asc"}],"actions":[{"name":"○","css":"action_o","button_css":"btn btn-primary btn-lg","keyArray":"r1","tweet":"o","enable0":"return (player.status == 'normal' && !header.playoff);","action0":"// ○を加算\nplayer.o++;\n// コンボ計算\nif (property.combo > 0 && player.combo === 1) {\n  player.o += property.combo;\n}\n// コンボ管理\nif (property.combo > 0) {\n  players.map(function(p) {\n    p.combo = 0;\n  });\n  player.combo = 1;\n}\nsetMotion(player, 'o');\naddQCount(players, header, property);"},{"name":"×","css":"action_x","button_css":"btn btn-danger btn-lg","keyArray":"S+r1","tweet":"x","enable0":"return (player.status == 'normal' && !header.playoff);","action0":"// swedishルールの場合\nif (angular.isArray(property.swedish)) {\n  if (property.swedish[player.o] !== undefined) {\n    player.x += property.swedish[player.o];\n  } else {\n    player.x += property.swedish[property.swedish.length - 1];\n  }\n  // swedishルールではない場合\n} else {\n  // ×を加算\n  player.x++;\n}\n// コンボ管理\nplayer.combo = 0;\n// up-downルールの場合、○を初期化\nif (property.updown) {\n  player.o = 0;\n}\n\nsetMotion(player, 'x');\naddQCount(players, header, property);"}],"global_actions":[{"name":"thru","button_css":"btn btn-default","group":"rule","keyboard":"Space","tweet":"thru","enable0":"return true;","action0":"addQCount(players, header, property);"},{"name":"next","button_css":"btn btn-default","group":"rule","enable0":"return true;","action0":"header.nowSet++;\nheader.maxRankDisplay = property.maxRanks[header.nowSet];\nheader.qCount = 1;\n\nvar nextOrder = 1000;\nangular.forEach(players.slice().sort(function(a, b) {\n  return a.order - b.order;\n}), function(player) {\n  if (player.present) {\n    switch (player.status) {\n      case \"win\":\n      case \"lose\":\n        player.order = -1;\n        break;\n      default:\n        player.order = (nextOrder++);\n    }\n  }\n});\n\nnextOrder = 0;\nangular.forEach(players.filter(function(player) {\n  return player.order >= 0;\n}).slice().sort(function(a, b) {\n  return a.order - b.order;\n}), function(player) {\n  player.order = (nextOrder++);\n});\n","keyArray":"","keyboard":"z"},{"name":"reserve","button_css":"btn btn-default","group":"rule","enable0":"return true;","action0":"var nextOrder = property.maxCount;\nangular.forEach(players.slice().sort(function(a, b) {\n  return a.order - b.order;\n}), function(player) {\n  if (player.present) {\n    switch (player.status) {\n      case \"win\":\n      case \"lose\":\n        var reserveOrder = (nextOrder++);\n        var reserve = players.filter(function(p) {\n          return p.order == reserveOrder;\n        });\n\n        if (reserve.length == 1) {\n          reserve[0].order = player.order;\n        }\n        player.order = -1;\n        break;\n    }\n  }\n});\n\nnextOrder = property.maxCount;\nangular.forEach(players.filter(function(player) {\n  return player.order >= property.maxCount;\n}).slice().sort(function(a, b) {\n  return a.order - b.order;\n}), function(player) {\n  player.order = (nextOrder++);\n});","keyArray":"","keyboard":"x"}],"global_actions_repeat":[],"tweet":{"o":"${handleName}◯　→${o}◯","x":"${handleName}×","thru":"スルー"},"judgement":"angular.forEach(players.filter(function(item) {\n  /* rankがない人に限定 */\n  return (item.rank === 0);\n}), function(player, i) {\n  /* win条件 */\n  if (player.o >= property.winningPoint) {\n\n    win(player, players, header, property);\n    player.winningSet = header.nowSet;\n    player.o = property.winningPoint;\n    player.combo = 0;\n    timerStop();\n    // 勝抜が出ると残るプレイヤーのポイントをリセット\n    angular.forEach(players, function(p) {\n      if (p.status == \"normal\") {\n        p.o = 0;\n      }\n    });\n\n  }\n  /* lose条件 */\n  if (player.x >= property.losingPoint) {\n    lose(player, players, header, property);\n    player.x = property.losingPoint;\n    player.combo = 0;\n    player.o = 0;\n    timerStop();\n  }\n});","calc":"header.rest = header.maxRankDisplay - players.filter(function(p) {\n  return (p.status == \"win\") && (p.winningSet == header.nowSet);\n}).length;\n\nvar nextOrder = 1000;\nangular.forEach(players, function(player, index) {\n  // pinch, chance\n  player.pinch = (player.x == property.losingPoint - 1) && (player.status == 'normal');\n  player.chance = (player.o + 1 + player.combo * property.combo >= property.winningPoint) &&\n    (player.status == 'normal');\n\n  if (angular.isUndefined(player.order) || player.order === -1) {\n    player.order = (nextOrder++);\n  }\n\n  // キーボード入力時の配列の紐付け ローリング等の特殊形式でない場合はこのままでOK\\\n  if (0 <= player.order && player.order < property.maxCount) {\n    player.present = true;\n    player.keyIndex = player.order;\n    switch (true) {\n      case (player.order <= 4):\n        player.line = \"line1\";\n        break;\n      case (player.order <= 9):\n        player.line = \"line2\";\n        break;\n      case (player.order <= 14):\n        player.line = \"line3\";\n        break;\n      default:\n        player.line = \"line4\";\n        break;\n    }\n\n  } else {\n    player.present = false;\n    player.keyIndex = 999;\n    player.line = \"left\";\n  }\n\n});","lines":[{"key":"line1","xType":true,"yType":false,"invisible":false,"zoom":1,"left":1,"right":0.52,"top":0,"y":0.75,"orderBy":"keyIndex"},{"key":"line2","orderBy":"keyIndex","xType":true,"yType":false,"invisible":false,"zoom":1,"left":0.48,"right":0,"y":0.75},{"key":"line3","orderBy":"keyIndex","xType":true,"yType":false,"invisible":false,"zoom":1,"left":1,"right":0.52,"y":0.35},{"key":"line4","orderBy":"keyIndex","xType":true,"yType":false,"invisible":false,"zoom":1,"left":0.48,"right":0,"y":0.35}]}